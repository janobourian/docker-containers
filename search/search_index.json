{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Docker Containers Crash Course","text":""},{"location":"index.html#notes-before-to-start","title":"Notes before to start","text":"<ul> <li>The story started with VeamWare and its Virtual Machine</li> <li>Some drawbacks:<ul> <li>Every OS consumes CPU, RAM, and other resources we'd rather use on applications</li> <li>Every VM and OS needs patching</li> <li>Every VM and OS needs monitoring</li> <li>VM are slow and not very portable</li> </ul> </li> <li>You can run Linux container on Windows using WSL (Windows Subsystem for Linux)</li> <li>Wasm is a WebAssembly:<ul> <li>You write your app in your favorite language and compile it as a Wasm binary that will run anywhere you have a Wasm runtime</li> </ul> </li> <li>Working in AI you need to access to specialized hardware such as:<ul> <li>Graphics Processing Units (GPU)</li> <li>Tensor Processing Units (TPU)</li> <li>Neural Processing Units (NPU)</li> </ul> </li> <li>Docker: Dock Worker</li> <li>Major parts to the Docker platform:<ul> <li>The CLI (client)</li> <li>The engine (server)</li> </ul> </li> <li>Container ecosystem:<ul> <li>The Open Container Initiative (OCI):<ul> <li>main specs:<ul> <li>The image-spec</li> <li>The runtime-spec</li> <li>The distribution-spec</li> </ul> </li> </ul> </li> <li>The CloudNative Computing Foundation (CNCF)<ul> <li>phases:<ul> <li>Sandbox</li> <li>Incubating</li> <li>Graduated</li> </ul> </li> </ul> </li> <li>The Moby Project</li> </ul> </li> </ul>"},{"location":"index.html#commands","title":"Commands","text":"<ul> <li><code>docker version</code> - All information about docker.</li> <li><code>docker info</code> - All information about docker status. </li> <li><code>docker --version</code> - Only the version.</li> <li><code>docker --help</code> - Fast help.</li> </ul>"},{"location":"containerizing_an_app.html","title":"Containerizing an app","text":""},{"location":"containerizing_an_app.html#basic-steps-to-containerizing-an-app","title":"Basic steps to containerizing an app","text":"<ul> <li>Create your app</li> <li>Create the Dockerfile</li> <li>Build the image</li> <li>Pull to the registry </li> <li>Run as container</li> </ul>"},{"location":"containerizing_an_app.html#push-the-image","title":"Push the image","text":"<p>Using docker hub or another images hub</p>"},{"location":"containerizing_an_app.html#run-the-app","title":"Run the app","text":"<p>Execute</p> <pre><code>docker run -it --detach --name targo --publish 8000:8000 janobourian/bank-app:maxine.bankapp\n</code></pre>"},{"location":"containerizing_an_app.html#about-layers","title":"About layers","text":"<ul> <li>Instructions that add content create a Layer<ul> <li>FROM</li> <li>RUN</li> <li>COPY</li> <li>WORKDIR</li> </ul> </li> <li>Instructions that does not add content create metadata<ul> <li>EXPOSE</li> <li>ENV</li> <li>CMD</li> <li>ENTRYPOINT</li> </ul> </li> </ul> <p>Type <code>docker history bank-app:maxine.bankapp</code> to show the instructions Type <code>docker inspect bank-app:maxine.bankapp</code> to see the layers</p>"},{"location":"containerizing_an_app.html#moving-to-production","title":"Moving to production","text":"<ul> <li>Big is bad!</li> <li>Stages is a good way to reduce the Image size</li> </ul> <pre><code>FROM folang:1.23.4-alpine AS base\nWORKDIR /src\nCOPY go.mod go.sum .\nRUN go mod download\nCOPY . . \n\nFROM base AS build-cliente\nRUN go build -o /bin/client ./cmd/client\n\nFROM base AS build-server\nRUN go build -o /bin/server ./cmd/server\n\nFROM scratch AS prod\nCOPY --from=build-client /bin/client /bin/\nCOPY --from=build-server /bin/server /bin/\nENTRYPOINT [ \"/bin/server\" ]\n</code></pre>"},{"location":"containerizing_an_app.html#buildx-buildkit-drivers-and-build-cloud","title":"Buildx, BuildKit, drivers, and Build Cloud","text":"<ul> <li>Client: Buildx</li> <li>Server: BuildKit</li> </ul>"},{"location":"containerizing_an_app.html#commands","title":"Commands","text":"<ul> <li><code>docker init</code></li> <li><code>docker build -t bank-app:maxine.bankapp .</code></li> <li><code>docker inspect bank-app:maxine.bankapp</code></li> <li><code>docker login</code></li> <li><code>docker tag &lt;current-tag&gt; &lt;new-tag&gt;</code></li> <li><code>docker tag bank-app:maxine.bankapp janobourian/bank-app:maxine.bankapp</code></li> <li><code>docker push janobourian/bank-app:maxine.bankapp</code></li> <li><code>docker run -it --detach --name targo --publish 8000:8000 janobourian/bank-app:maxine.bankapp</code></li> <li><code>docker history janobourian/bank-app:maxine</code></li> <li><code>docker inspect janobourian/bank-app:maxine</code></li> <li><code>docker buildx ls</code></li> <li><code>docker buildx inspect &lt;BUILDX_NAME&gt;</code></li> <li><code>docker buildx create --driver=docker-container --name=container</code></li> <li><code>docker buildx use container</code></li> <li><code>docker buildx build --builder=container --platform=linux/amd64,linux/arm64 -t janobourian/bank-app:maxine.bankapp --push .</code></li> </ul>"},{"location":"docker-cheatsheet.html","title":"Docker CheatSheet","text":""},{"location":"docker-cheatsheet.html#help","title":"Help","text":"<ul> <li><code>docker --help</code></li> <li><code>docker &lt;COMMAND&gt; --help</code></li> </ul>"},{"location":"docker-cheatsheet.html#commands","title":"Commands","text":"<ul> <li><code>docker version</code> - All information about docker</li> <li><code>docker info</code> - All information about docker status</li> <li><code>docker --version</code> - Only the docker container version</li> <li><code>docker images</code> - List all current images in your docker</li> <li><code>docker pull &lt;IMAGE_NAME&gt;:&lt;VERSION&gt;</code> - Pull a specific image from docker hub</li> <li><code>docker run --name &lt;CONTAINER_NAME&gt; --detach --publish &lt;INTERNAL_PORT&gt;:&lt;EXPOSE_PORT&gt; &lt;IMAGE_NAME&gt;:&lt;VERSION&gt;</code> - Run a container</li> <li><code>docker ps</code> - List only active containers</li> <li><code>docker ps --all</code> - List all containers</li> <li><code>docker exec -it &lt;CONTAINER_NAME&gt; &lt;COMMAND&gt;</code> - Execute some commands in interactive mode</li> <li><code>docker stop &lt;CONTAINER_NAME&gt;</code> - Stop a container</li> <li><code>docker rm &lt;CONTAINER_NAME&gt;</code> - Delete a container</li> <li><code>docker rmi &lt;IMAGE_NAME&gt;:&lt;VERSION&gt;</code> - Delete an image</li> <li><code>docker build -t &lt;IMAGE_NAME&gt;:&lt;VERSION&gt; .</code> - Build an image with a specific tag</li> <li><code>docker start &lt;CONTAINER_NAME&gt;</code> - Start a specific container</li> <li><code>docker stop &lt;CONTAINER_NAME&gt;</code> - Stop a specific container</li> <li><code>docker restart &lt;CONTAINER_NAME&gt;</code> - restart a specific container</li> <li><code>docker init</code> - Start a container using the docker steps</li> <li><code>docker tag &lt;CURRENT_TAG&gt; &lt;NEW_TAG&gt;</code> - Create a tag</li> </ul>"},{"location":"docker-cheatsheet.html#flags","title":"Flags","text":"<ul> <li><code>--name string</code> - The Docker container name</li> <li><code>[-d | --detach]</code> - Working on detached mode, working with the container in background</li> <li><code>[-p | --publish] &lt;INTERNAL_PORT&gt;:&lt;EXPOSE_PORT&gt;</code>- Port mapping</li> <li><code>ps [-a | --all]</code>- List all containers, even those in the stopped state</li> <li><code>exec [-it | -i -t | --interactive --tty]</code> - Execute in interactive mode</li> <li><code>exec [--user | -u] &lt;USERNAME&gt;</code> - Execute in interactive mode using a specific user</li> <li><code>start [-ia | -i -a]</code> - Attach and interactive mode</li> <li><code>build [-t | --tag]</code> - Tag an image</li> <li><code>run --env-file &lt;LIST_ENV_FILES&gt;</code> - Use a list of env files</li> <li><code>run [--rm]</code> - Automatically remove the container and its associated anonymous volumes when it exits</li> <li><code>run [--restart]</code> - Restart policy to apply when a container exits (default \"no\")</li> </ul>"},{"location":"docker-cheatsheet.html#compose","title":"Compose","text":"<ul> <li><code>docker compose version</code> - To show the docker composer version</li> <li><code>docker compose up</code> - Create and start containers</li> <li><code>docker compose build &lt;SERVICE&gt;</code> - Build a specific service</li> <li><code>docker compose down</code> - Down the services</li> <li><code>docker compose down -v --remove-orphans</code> - Remove volumes and remove containers for services not defined in the Compose file</li> <li><code>docker compose build --no-cache &lt;SERVICE&gt;</code> - Do not use cache when building the image</li> <li><code>docker compose ps</code> - List containers</li> <li><code>docker compose logs -f</code> - Follow log output</li> <li><code>docker compose logs -f &lt;SERVICE&gt;</code> - Follow log output with specific service</li> </ul>"},{"location":"docker-cheatsheet.html#images","title":"Images","text":"<ul> <li><code>docker inspect &lt;IMAGE_NAME&gt;:&lt;VERSION&gt;</code></li> <li><code>docker history &lt;IMAGE_NAME&gt;:&lt;VERSION&gt;</code></li> <li><code>docker manifest inspect &lt;IMAGE_NAME&gt;:&lt;VERSION&gt;</code></li> </ul>"},{"location":"docker-engine.html","title":"Docker Engine","text":"<ul> <li> <p>Docker Engine is jargon for the server-side components of Docker that run and manage containers</p> </li> <li> <p>Basic Components:</p> <ul> <li>docker CLI<ul> <li>{API}</li> </ul> </li> <li>Docker Engine<ul> <li>daemon</li> </ul> </li> <li>Plugins and other</li> </ul> </li> <li> <p>More detail:</p> <ul> <li>docker CLI<ul> <li>Commands CLI</li> </ul> </li> <li>daemon<ul> <li>Expose API</li> </ul> </li> <li>containerd<ul> <li>Lifecycle management (start, stop, delete...)</li> </ul> </li> <li>shim<ul> <li>Enables pluggable lower level</li> </ul> </li> <li>Rc - runc <ul> <li>Interface with kernel</li> </ul> </li> <li>Runing containers</li> </ul> </li> <li> <p>Container-related standars:</p> <ul> <li>image-spec</li> <li>runtime-spec</li> <li>distribution-spec</li> </ul> </li> <li> <p>runc: is the reference implementation of the OCI runtime-spec, low-level.</p> </li> <li> <p>containerd: manage lifecycle events such as starting, stopping, and deleting containers, high-level.</p> </li> <li> <p>The daemon can expose the API on a local socket or over the network. On Linux, the local socket is <code>/var/run/docker.sock</code></p> </li> <li> <p>daemonless containers: is the ability to stop, restart, and even update the Docker daemon without impacting running containers.</p> </li> <li> <p>Simmarizes the process</p> <ul> <li>docker CLI<ul> <li>Convert docker run command into API request and send to API (daemon)</li> </ul> </li> <li>daemon<ul> <li>Receive API request and instruct containerd to start a new container</li> </ul> </li> <li>containerd<ul> <li>Receive instruction to create new container and pass instruction to runc</li> </ul> </li> <li>shim<ul> <li>Becomes container's parent process and communicates with containerd</li> </ul> </li> <li>runc<ul> <li>Builds new container and exits</li> </ul> </li> </ul> </li> </ul>"},{"location":"docker-engine.html#commands","title":"Commands","text":"<ul> <li><code>docker pull nginx:latest</code></li> <li><code>docker run -d --name web1 nginx:latest</code></li> <li><code>docker run --name web1 -d --publish 8080:8080 test:latest</code></li> <li><code>docker ps</code></li> <li><code>docker ps -a</code></li> <li><code>docker ps --all</code></li> <li><code>docker rm web1 -f</code></li> </ul>"},{"location":"getting-started.html","title":"Getting Started","text":"<ul> <li>Get and work with Docker:</li> <li>Docker Desktop</li> <li>Multipass</li> <li>Server installs on Linux</li> </ul>"},{"location":"getting-started.html#the-ops-perspective","title":"The Ops perspective","text":"<ul> <li>Images are objects that contain everything an app needs to run</li> <li>You can start a new Bash process inside the container</li> </ul>"},{"location":"getting-started.html#the-dev-perspective","title":"The Dev perspective","text":"<ul> <li>Containers are all about applications</li> <li>Example: </li> </ul> <pre><code>FROM alpine\nLABEL maintainer=\"your-email@example.com\"\nRUN apk add --update nodejs npm curl\nCOPY . /src\nWORKDIR /src\nRUN  npm install\nEXPOSE 8080\nENTRYPOINT [\"node\", \"./app.js\"]\n</code></pre>"},{"location":"getting-started.html#commands","title":"Commands","text":"<ul> <li><code>docker --version</code></li> <li><code>docker version</code></li> <li><code>docker info</code></li> <li><code>docker --help</code></li> <li><code>docker images</code></li> <li><code>docker pull nginx:latest</code></li> <li><code>docker run --name test -d -p 8080:80 nginx:latest</code></li> <li><code>docker ps</code></li> <li><code>docker ps -a</code></li> <li><code>docker exec -it test bash</code></li> <li><code>docker stop test</code></li> <li><code>docker rm test</code></li> <li><code>docker build -t test:latest .</code></li> <li><code>docker run -d --name web1 --publish 8080:8080 test:latest</code></li> <li><code>docker rm web1 -f</code></li> <li><code>docker rmi test:latest</code></li> </ul>"},{"location":"getting-started.html#flags","title":"Flags","text":"<ul> <li><code>--name</code> - The Docker container name</li> <li><code>-d/--detach</code> - Working on detached mode, working with the container in background</li> <li><code>-p/--publish</code> - Port mapping </li> <li><code>-a/--all</code> - List all container, even those in the stopped state</li> </ul>"},{"location":"multi-container-apps.html","title":"Multi-container apps with Compose","text":""},{"location":"multi-container-apps.html#the-network-is-important","title":"The network is important","text":""},{"location":"multi-container-apps.html#for-the-frontend-app","title":"For the Frontend app","text":"<pre><code>docker build -t ai-chatbot:frontend .\ndocker run -it --detach --name macorina --publish 80:80 ai-chatbot:frontend\n</code></pre>"},{"location":"multi-container-apps.html#for-the-backend-app","title":"For the Backend app","text":"<pre><code>docker build -t ai-chatbot:backend .\ndocker run -it --detach --name mastroeni --publish 8000:8000 ai-chatbot:backend\n</code></pre>"},{"location":"multi-container-apps.html#for-the-ai-model-app","title":"For the AI model app","text":"<pre><code>docker build -t ai-chatbot:ai-model .\ndocker run -it --detach --name macario --publish 8001:8000 --env-file /Users/frgonzal/Documents/vit/docker-containers/ai-compose/ai-model/.env ai-chatbot:ai-model\n</code></pre>"},{"location":"multi-container-apps.html#commands","title":"Commands","text":"<ul> <li><code>docker compose version</code></li> <li><code>docker compose up</code></li> <li><code>docker compose build frontend</code></li> <li><code>docker compose up</code></li> <li><code>docker compose down</code></li> <li><code>docker compose down -v --remove-orphans</code></li> <li><code>docker system prune -f</code></li> <li><code>docker compose build --no-cache</code></li> <li><code>docker compose up --detach</code></li> <li><code>docker compose ps</code></li> <li><code>docker compose logs -f</code></li> <li><code>docker compose logs -f backend</code></li> </ul>"},{"location":"working-with-containers.html","title":"Working with containers","text":"<ul> <li>To install nano inside gcc:latest docker container <code>apt-get update &amp;&amp; apt-get install nano -y</code></li> </ul>"},{"location":"working-with-containers.html#vms-vs-containers","title":"VMs vs Containers","text":""},{"location":"working-with-containers.html#images-and-containers","title":"Images and containers","text":"<ul> <li>You can start multiple containers from a single image. Images are read-only, but every container has a read-write layer. </li> </ul>"},{"location":"working-with-containers.html#pulling-image-and-start-container","title":"Pulling image and start container","text":"<pre><code>docker pull nginx:latest\ndocker run -it -d --name dashboard --publish 80:80 nginx:latest\ndocker exec -it dashboard sh\ncd /usr/share/nginx/html\n</code></pre>"},{"location":"working-with-containers.html#how-containers-start-apps","title":"How containers start apps","text":"<p>There are three ways you can tell Docker how to start an app in a container:</p> <ul> <li>An <code>Entrypoint</code> instruction in the image</li> <li>A <code>cmd</code> instruction in the image</li> <li>A <code>cli</code> argument</li> </ul>"},{"location":"working-with-containers.html#connecting-to-a-running-container","title":"Connecting to a running container","text":"<ul> <li>Interactive</li> <li>Remote execution</li> </ul>"},{"location":"working-with-containers.html#self-healing-container-with-restart-policies","title":"Self-healing container with restart policies","text":"<ul> <li>no (default)</li> <li>on-failure</li> <li>always</li> <li>unless-stopped</li> </ul>"},{"location":"working-with-containers.html#docker-commands","title":"Docker commands","text":"<ul> <li><code>docker build -t demoapp:latest .</code></li> <li><code>docker run -d --name macorina --publish 8000:8000 demoapp:latest</code></li> <li><code>docker exec -it macorina sh</code></li> <li><code>docker pull python:latest</code></li> <li><code>docker run -it -d --name macarena python:latest</code></li> <li><code>docker exec -u root -it macarena sh</code></li> <li><code>docker run -it --detach --name bang --publish 8000:8000 --env-file .env fastapi:latest</code></li> <li><code>docker inspect nginx:latest | grep Entrypoint -A 3</code></li> <li><code>docker run --rm --detach alpine sleep 60</code></li> <li><code>docker exec -it macarena sh</code></li> <li><code>docker exec macarena ps</code></li> <li><code>docker inspect macarena</code></li> <li><code>docker inspect &lt;CONTAINER_NAME&gt;</code></li> <li><code>docker inspect &lt;IMAGE_NAME&gt;</code></li> <li><code>docker stop macarena</code></li> <li><code>docker restart macarena</code></li> <li><code>docker rm macarena -f</code></li> <li><code>docker run --name neversaydie -it --restart always alpine sh</code></li> <li><code>docker rm ${docker ps -aq) -f</code></li> <li><code>docker rmi $(docker images -q)</code></li> </ul>"},{"location":"working-with-images.html","title":"Working with images","text":"<ul> <li>The most lightweight image is Alpine Linux</li> <li>Image registries is where we store images.<ul> <li>Build -&gt; Share -&gt; Run</li> </ul> </li> <li>Image naming and tagging<ul> <li>Registry/User-Org/Repository:Image-tag</li> </ul> </li> <li>Images are a collection of loosely connected read-only layers where each layer comprises one or more files.</li> <li>Content hashes vs distribution hashes<ul> <li>Content hash</li> <li>Distribution hash</li> </ul> </li> <li>Multi-architecture images<ul> <li>Manifest lists<ul> <li>A list of architectures supported by an image tag</li> </ul> </li> <li>Manifests</li> </ul> </li> </ul>"},{"location":"working-with-images.html#buildx","title":"buildx","text":"<ul> <li><code>buildx</code> command makes it easy to create multi-architecture images. <ul> <li>Emulation</li> <li>Build Cloud</li> </ul> </li> </ul>"},{"location":"working-with-images.html#commands","title":"Commands","text":"<ul> <li><code>docker images</code></li> <li><code>docker pull python:latest</code></li> <li><code>docker run -it --name macarena -d python:latest</code></li> <li><code>docker start -ai macarena</code></li> <li><code>docker pull elixir:latest</code></li> <li><code>docker run -it --name iex_shell -d elixir:latest</code></li> <li><code>docker start -ai iex_shell</code></li> <li><code>docker inspect node:latest</code></li> <li><code>docker history node:latest</code></li> <li><code>docker manifest inspect nginx:latest</code> </li> <li><code>docker pull gcc</code></li> <li><code>docker run -it --name samba gcc:latest bash</code></li> <li><code>docker images --digests alphine:latest</code></li> <li><code>docker buildx imagetools inspect amazonlinux:latest</code></li> <li><code>docker scout quickview nginx:latest</code></li> <li><code>docker images -q</code></li> <li><code>docker rmi $(docker images -q) -f</code></li> </ul>"}]}